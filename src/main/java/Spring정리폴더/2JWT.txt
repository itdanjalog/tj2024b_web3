https://mvnrepository.com/

✅ JWT 정의
**JWT (JSON Web Token)**는 JSON 포맷을 사용하여 데이터를 안전하게 전달하기 위한 토큰 기반 인증 방식입니다.
 주로 사용자 인증 및 정보 전달에 사용되며, 서버 간 또는 클라이언트와 서버 간의 정보를 안전하게 교환할 수 있게 해줍니다.

 ✅ JWT 목적
 JWT는 주로 웹 애플리케이션에서 인증 및 권한 부여를 위해 사용됩니다.
 주된 목적:
 사용자 인증: 사용자 로그인이 완료된 후, 서버는 JWT를 발급하고 클라이언트는 이 토큰을 저장하여 인증을 유지합니다.
 정보 안전하게 전송: 서버 간 통신이나 API 호출 시, 정보를 안전하게 전달하는 데 사용됩니다.
 세션 관리: 세션 기반 인증 대신 JWT를 사용한 Stateless 인증을 지원합니다.

 장점:
 무상태(stateless): 서버는 세션을 저장하지 않으므로 확장성 측면에서 유리합니다.
 크로스 도메인 지원: JWT는 URL, 헤더, 쿠키 등에 담을 수 있어 다양한 환경에서 사용할 수 있습니다.
 보안: 서명된 JWT는 내용의 무결성을 보장하고, 이를 통해 중간자 공격을 방지할 수 있습니다.

 ✅ JWT 구조
헤더 (Header)
    헤더는 JWT의 메타데이터를 담고 있습니다. 보통 두 가지 정보를 포함합니다:
    타입: 토큰의 타입을 지정하는 정보 (대개 "JWT"로 설정됨)
    서명 알고리즘: 토큰을 서명할 때 사용하는 알고리즘 정보 (예: HS256, RS256 등)
    {
      "alg": "HS256",   alg: JWT 서명에 사용된 알고리즘을 나타냅니다. 여기서는 HS256이 사용되었습니다.
      "typ": "JWT"      typ: JWT 토큰의 타입을 지정합니다. 일반적으로 "JWT"가 사용됩니다.
    }
페이로드 (Payload)
    페이로드는 **클레임 (Claims)**이라고 불리는 정보들을 포함하는 부분입니다. 클레임은 JWT에 담을 수 있는 정보이며, 크게 세 가지 유형으로 분류됩니다:
    등록된 클레임 (Registered Claims): JWT에 미리 정의된 표준화된 클레임들입니다. (예: sub, iat, exp 등)
    공개 클레임 (Public Claims): 사용자 정의가 가능한 클레임들입니다. 다른 사람들과 공유할 수 있는 정보 (예: user_id, role, email 등)
    비공개 클레임 (Private Claims): 발급자와 수신자 간에 동의하여 사용하는 정보입니다. 외부에서 이해할 수 없는 데이터를 담을 때 사용됩니다.
    {
      "sub": "1234567890",    // 사용자 ID         sub: 주체를 나타냅니다. 일반적으로 사용자 ID나 고유 식별자가 담깁니다.
      "name": "John Doe",     // 사용자 이름         name: 사용자 이름이나 이메일 등 사용자 정보를 담을 수 있습니다.
      "iat": 1516239022       // 발급 시간 (Issued At) iat: 발급 시간을 나타내는 타임스탬프입니다. (Issued At)
    }
서명 (Signature)
    서명은 JWT의 무결성을 보장하기 위해 사용됩니다. JWT는 헤더와 페이로드를 인코딩한 후, 지정된 알고리즘을 사용하여 서명을 생성합니다.
    서명은 비밀 키 또는 개인 키를 사용하여 생성되며, 이를 통해 JWT가 변조되지 않았음을 검증할 수 있습니다.
    HMACSHA256: **HMAC (Hash-based Message Authentication Code)**을 사용하여 SHA-256 알고리즘으로 서명합니다.
    base64UrlEncode(header): 헤더를 Base64Url로 인코딩합니다.
    base64UrlEncode(payload): 페이로드를 Base64Url로 인코딩합니다.
    secret: JWT를 서명할 때 사용되는 비밀 키입니다.

<헤더>.<페이로드>.<서명>
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

eyJhbGciOiJIUzI1NiJ9.
eyJzdWIiOiJxd2UiLCJpYXQiOjE3NDQ3MzQ5NDMsImV4cCI6MTc0NDczODU0M30.
U3lYAzHoDF-LER5jDLcx-Smzn_s_YGSdbVHmMtFmv-8

JWT 해석 과정
헤더(Base64Url 디코딩): {"alg":"HS256","typ":"JWT"}
페이로드(Base64Url 디코딩): {"sub":"1234567890","name":"John Doe","iat":1516239022}
서명(Base64Url 디코딩): JWT 서명 부분은 비밀 키로 검증되며, 클라이언트가 보내는 토큰이 변조되지 않았는지 확인합니다.

헤더	JWT의 타입과 서명 알고리즘 정보	{"alg":"HS256","typ":"JWT"}
페이로드	실제 사용자 정보 및 클레임 정보	{"sub":"1234567890","name":"John Doe","iat":1516239022}
서명	헤더와 페이로드를 서명 알고리즘으로 서명	서명 값 (비밀 키를 이용해 생성)

========================

항목	        세션(Session)	                JWT (JSON Web Token)
저장 위치	서버          	                클라이언트
상태 관리	서버가 상태 관리	                클라이언트가 상태 관리
확장성	    서버 상태 공유 필요	            서버 무상태 (Stateless), 확장성 뛰어남
보안	세션      ID는 서버에 저장, 유출 시 위험	    토큰 유출 시 위험, 서명된 토큰으로 무결성 보장
성능	서버      메모리 부하 있음	                서버 부담 없음, 클라이언트에서 처리
사용 예시	작은 애플리케이션, 로그인 시스템	    분산 시스템, 마이크로서비스, SPA
만료 처리	서버에서 관리	                    클라이언트에서 관리, 리프레시 토큰 필요

---
세션은 서버에 상태를 저장하며, 보안에 유리하지만, 확장성에 제약이 있을 수 있습니다.
JWT는 서버에 상태를 저장하지 않고 클라이언트에 토큰을 저장하여 확장성이 뛰어나지만, 보안에 주의가 필요합니다.

 ✅ 사용법
 1. Gradle 설정 (Dependency 추가)
    implementation 'io.jsonwebtoken:jjwt-api:0.12.6'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.6'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.6'
2. JWT 생성



HS256: 보통 256비트로 충분한 보안을 제공하며 성능도 더 빠릅니다. 기본적인 보안 요구사항을 충족하는 데 적합합니다.
HS512: HS256보다 더 강력한 보안을 제공하지만, 성능에서 약간의 오버헤드가 발생할 수 있습니다. 보안이 중요한 상황에서 사용합니다.


[ Base64 정의]
Base64는 이진 데이터를 텍스트 문자열로 변환하는 인코딩 방식입니다. 이를 통해 이진 데이터(예: 이미지, 파일, 암호화된 정보 등)를 ASCII 문자열 형식으로 변환할 수 있습니다.
Base64는 주로 HTTP 프로토콜, 이메일, URL 등에서 이진 데이터를 텍스트 형식으로 전송하거나 저장할 때 사용됩니다.
Base64는 64개의 서로 다른 ASCII 문자를 사용하여 이진 데이터를 텍스트로 표현합니다:
A-Z, a-z, 0-9 (대소문자 알파벳과 숫자)
+와 / (URL-safe에서는 -와 _ 사용)
Base64로 인코딩된 데이터는 4개의 문자로 3바이트의 데이터를 표현합니다.
즉, 3바이트의 이진 데이터를 4문자의 텍스트로 변환합니다. 이 변환 과정에서 데이터의 크기가 약 33% 증가합니다.

[ Base64가 필요한 이유 ]
이진 데이터를 텍스트로 변환
프로토콜 제약을 해결
URL과 파일 시스템에서의 안전성
간편한 텍스트 처리
보안 및 암호화 과정에서 사용
- 컴퓨터는 **이진수(0과 1)**를 사용해서 정보를 처리하는데, 이진수는 사람이 보기 어렵고, 인터넷이나 이메일 같은 시스템에서 전송하기도 불편해요. 그래서 Base64는 이진 데이터를 문자들로 변환해서 더 쉽게 전송하거나 저장할 수 있도록 도와줘요.
- 컴퓨터가 처리하는 데이터: 01101001 (이진수)
  Base64로 바꾼 데이터: aG9yYQ== (문자 형태)

1. HS256 정의
HS256(HMAC SHA-256)은 대칭 키 암호화 방식 중 하나로, SHA-256 해시 알고리즘을 사용하는 HMAC(HMAC: Hash-based Message Authentication Code) 방식을 기반으로 한 서명 알고리즘입니다.
HMAC은 비밀 키를 이용하여 데이터를 해싱하고, 그 결과를 서명으로 사용하여 데이터의 무결성을 검증합니다.
SHA-256은 256비트의 해시 값을 생성하는 암호화 해시 함수로, 해시 결과를 **256비트(32바이트)**로 생성합니다.
HS256은 JWT(JSON Web Token)에서 토큰을 서명하고 검증하는 데 자주 사용되는 알고리즘입니다. 대칭키 방식이기 때문에, 암호화와 복호화에 동일한 비밀키를 사용합니다.

1. HS512 정의
HS512는 HMAC SHA-512 방식을 사용하는 서명 알고리즘으로, SHA-512 해시 알고리즘을 기반으로 하는 대칭키 암호화 방식입니다.
SHA-512는 512비트 해시 값을 생성하는 해시 함수로, HS256보다 더 강력한 보안을 제공합니다.
HS512는 HMAC 방식으로, 대칭키 암호화를 사용하여 서명을 생성하고, 이 서명을 검증하는 데 사용됩니다.
HS512는 JWT와 같은 시스템에서 강력한 보안이 요구될 때 사용됩니다. 512비트의 서명은 SHA-256보다 더 많은 비트로 데이터를 해싱하여, 더 안전한 보안을 제공합니다.


특성	            HS256	                HS512
해시알고리즘	    SHA-256 (256비트)	    SHA-512 (512비트)
보안성	        SHA-256보다 낮은 보안	    SHA-256보다 더 강한 보안
속도	            빠른 속도	            HS256보다 느림
사용처	        대부분의 시스템에서 적합	높은 보안이 필요한 시스템
주요 장점	    빠르고 간단한 서명 및 검증	더 높은 보안, 더 긴 서명 생성


- 해시 알고리즘은 **입력값(데이터)을 고정된 크기의 출력값(해시 값)**으로 변환하는 함수
    - 예를 들어, SHA-256은 항상 256비트(32바이트)의 결과를 생성합니다.
    - "사과" → abc123
      "배" → def456
      두 개는 다른 데이터를 넣었지만, 각각 고정된 크기의 코드로 변환된 거죠.

